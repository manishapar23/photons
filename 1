// Kinematic variables for RDF
#include <vector>
#include <stdexcept>
#include <string>
#include <algorithm>
#include <iostream>
#include <cmath>
#include "ROOT/RVec.hxx"



using namespace ROOT::VecOps;
using rvec_f = const RVec<float> &;
using rvec_b = const RVec<bool> &;
	
// this function defines the cuts
float get_CUT(unsigned int NP, rvec_f M, rvec_f PT, rvec_f ETA, rvec_f PHI, rvec_b PID, float ptMin, float etaMin) 
        {
                if (NP > 3)
                 {
                   if (PT[3] < ptMin) return -95.;
                   if ((fabs(ETA[0]) > etaMin) or (fabs(ETA[1]) > etaMin) or (fabs(ETA[2]) > etaMin) or (fabs(ETA[3]) > etaMin)) return -90.;                                                  if (PID[0]==1 && PID[1]==1 && PID[2]==1 && PID[3]==1) {
			//passed the cuts
			return 1.;
		
		   }
		 }
	}



//this function gets the pairing by minimizing the dR
float get_min_Mpair(unsigned int NP, rvec_f M, rvec_f PT, rvec_f ETA, rvec_f PHI, int i, int j);

float Mavg(int i, int j) {
	return abs(Photon_mass[i] - Photon_mass[j]) / (Photon_mass[i] + Photon_mass[j]) }
       {

         TLorentzVector v1;
         TLorentzVector v2;
         TLorentzVector v3;
         TLorentzVector v4;
         v1.SetPtEtaPhiM(PT[0],ETA[0],PHI[0],M[0]);
         v2.SetPtEtaPhiM(PT[1],ETA[1],PHI[1],M[1]);
         v3.SetPtEtaPhiM(PT[2],ETA[2],PHI[2],M[2]);
         v4.SetPtEtaPhiM(PT[3],ETA[3],PHI[3],M[3]);

M12 = Mavg(0, 1)
M34 = Mavg(2, 3)
M13 = Mavg(0, 2)
M24 = Mavg(1, 3)
M14 = Mavg(0, 3)
M23 = Mavg(1, 2)

 if (min({M12, M34, M13, M24, M14, M23}) == M12 or M34) {
           //      cout << "combo 1"  << endl;
	 float am1 = (v1+v2).M();
	 float am2 = (v3+v4).M();
	 float amavg = (am1+am2)/2;
	 return amavg
 	 }
         else if (min({{M12, M34, M13, M24, M14, M23}) == M13 or M24) {
 	   float am1 = (v1+v3).M();
           float am2 = (v2+v4).M();
           float amavg = (am1+am2)/2.;
           return amavg;
	}
	 else if (min({{M12, M34, M13, M24, M14, M23}) == M14 or M23) {
           float am1 = (v1+v4).M();
           float am2 = (v2+v3).M();
           float amavg = (am1+am2)/2.;
           return amavg;

         }
         else {
 		return -999.; // failed

	} 
